<!---
;;
;;  This softeware is Copyright (c) 2009 A.F. Haffmans 
;;
;;    This file is part of cl-bliky.
;;
;;    cl-bliky is free software: you can redistribute it and/or modify
;;    it under the terms of the GNU General Public License as published by
;;   the Free Software Foundation, either version 3 of the License, or
;;    (at your option) any later version.
;;
;;    cl-bliky is distributed in the hope that it will be useful,
;;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;    GNU General Public License for more details.
;;
;;    You should have received a copy of the GNU General Public License
;;    along with cl-bliky.  If not, see <http://www.gnu.org/licenses/>.
;;
;;

--->

<?xml version="1.0"?>
<rss version='2.0' xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title> Programmer Notes </title>
    <link>  http://fons.github.com/ </link>
    <description> This is mostly concerned with programming. </description>
    <pubDate> Sun, 30 Aug 2009 10:40:27 EST </pubDate>
    
    <item>
      <title> Simplified command line processing with dyn-options.py </title>
      <link> http://fons.github.com/simplified-command-line-processing-with-dyn-optionspy.html </link>
      <description> Am I the only one in the world who feels that using python's  *getopt* is a bit of a struggle ? It involves a lot of boiler plate. 
Tedious refactoring is required each time you add or change an option.  
This is not specific to Python, as most languages have a similar facility to parse the command line. which is similarly annoying.

   
I decided to create an easier way to process command line options, by transforming the command line into an immutable (read-only) object. 
The result is [dyn_options](http://github.com/fons/dyn_options/tree/master). 
  

[dyn_options](http://github.com/fons/dyn_options/tree/master) considers every string on the command line which starts with either  - or -- (i.e. a single or double dash) an option flag. 
The value of the option flag is a concatenation of everything that follows it, until the next flag is encountered.  
A simple option flag is one without explicit values and is considered a boolean flag, set to *True*.

[dyn_options](http://github.com/fons/dyn_options/tree/master) creates a read-only object, with attributes and values set to the command line option flags and values respectively.

   
So, '--opt4 hello world' will be converted to an option flag  called *opt4*, with a value of *hello world*. 
This makes dealing with spaces on the command line a lot easier. <br><br> </description> 
      <guid> http://fons.github.com/simplified-command-line-processing-with-dyn-optionspy.html </guid>      
      <pubDate> Sat, 29 Aug 2009 19:15:49 EST </pubDate>
    </item>
    
    <item>
      <title> Factorials, Tail Recursion and CPS ... in C  </title>
      <link> http://fons.github.com/factorials-tail-recursion-and-cps--in-c-.html </link>
      <description> Recursive algorithms are elegant. 

However, if the recursion is not a  
[tail call](http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-453.pdf)  
the growth of the stack leads to a stack overflow. 


Tail call recursion is a technique whereby the last call in a recursive function 
does not depend on the variables pushed on the stack. 
In other words the function 
returns the value of its additional (recursive) call.


Functional languages like Haskell or Lisp are designed to 
support the use of tail recursive algorithms.
The JVM -although now the target platform of a lisp like 
[clojure](closure.org) or 
a hybrid functional language like [scala](www.scala-lang.org) - 
[does not support tail recursion at all](http://blogs.sun.com/jrose/entry/tail_calls_in_the_vm).

In C/C++ the compiler can in fact 
replace tail recursive calls with a simple loop, thereby eliminating the allocation 
for additional stack frames all together.

In this post I'll consider various implementations of the humble factorial to illustrate 
some of these things. </description> 
      <guid> http://fons.github.com/factorials-tail-recursion-and-cps--in-c-.html </guid>      
      <pubDate> Sun, 09 Aug 2009 10:27:45 EST </pubDate>
    </item>
    
    <item>
      <title> CL-BLIKY : A simple lisp based blog engine </title>
      <link> http://fons.github.com/cl-bliky--a-simple-lisp-based-blog-engine.html </link>
      <description> I 'm writing this using a self rolled blog engine called cl-bliky. I'm indebted to an excellent 
[tutorial](http://roeim.net/vetle/docs/cl-webapp-intro/) 
put together by [Vetle Roeim](http://roeim.net/vetle/). 
His goal was obviously to put together a compelling tutorial and he succeeded. 
My goal was to use lisp in a small programming project, and developing a simple and easily 
customizable blog engine seemed like a good start. </description> 
      <guid> http://fons.github.com/cl-bliky--a-simple-lisp-based-blog-engine.html </guid>      
      <pubDate> Sun, 19 Jul 2009 11:49:05 EST </pubDate>
    </item>
    
  </channel>
</rss>

