<?xml version="1.0" encoding="UTF-8"?>
<!--
;;
;;  This softeware is Copyright (c) 2009 A.F. Haffmans 
;;
;;    This file is part of cl-bliky.
;;
;;    cl-bliky is free software: you can redistribute it and/or modify
;;    it under the terms of the GNU General Public License as published by
;;   the Free Software Foundation, either version 3 of the License, or
;;    (at your option) any later version.
;;
;;    cl-bliky is distributed in the hope that it will be useful,
;;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;    GNU General Public License for more details.
;;
;;    You should have received a copy of the GNU General Public License
;;    along with cl-bliky.  If not, see <http://www.gnu.org/licenses/>.
;;
;;

-->

<?xml-stylesheet type="text/xsl" media="screen" href="/~d/styles/rss2full.xsl"?>
<?xml-stylesheet type="text/css" media="screen" href="http://feeds.feedburner.com/~d/styles/itemcontent.css"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
<!-- rss version='2.0' xmlns:atom="http://www.w3.org/2005/Atom" -->
  <channel>
    <title> Mohegan SkunkWorks </title>
    <link>  http://fons.github.com/ </link>
    <description> This web log is concerned mostly with my interest in programming languages, algorithms, machine learning, search or other software endeavors. &lt;BR&gt;&lt;BR&gt; </description>
    <pubDate> Mon, 08 Feb 2010 07:42:12 EST </pubDate>
    
    <item>
      <title> cl-mongo </title>
      <link> http://fons.github.com/cl-mongo.html </link>
      <description> &lt;P&gt;&lt;A HREF="http://www.mongodb.org"&gt;mongo&lt;/A&gt; is a scalable, high-performance, open source, schema-free, document-oriented database. I was introduced to mongo at the &lt;A HREF="http://www.meetup.com/mysqlnyc/messages/8346727/"&gt;new-york mysql meetup&lt;/A&gt;. Two things made mongo look attractive: inter-operability and document centric storage. &lt;BR&gt; &lt;BR&gt; I'm familiar with the &lt;A HREF="http://common-lisp.net/project/elephant/"&gt;elephant&lt;/A&gt; persistence framework in lisp. However elephant objects are not readable (as far as I know) in languages other than lisp.That makes inter-operating with other platforms difficult. A traditional rdms requires some sort of schema if you want to use it effectively. Mongo on the other hand is optimized for the the kind of free form document storage I'm looking for. &lt;BR&gt; &lt;BR&gt; Mongo comes with set of drivers but was missing was a lisp driver. This looked like a good project to get better acquainted with lisp and mongo.&lt;BR&gt; &lt;BR&gt; So I set out to try to write one and the result is &lt;A HREF="http://github.com/fons/cl-mongo"&gt;cl-mongo&lt;/A&gt;. At this stage it's close to having the capabilities I'm looking for, but &lt;A HREF="http://github.com/fons/cl-mongo"&gt;cl-mongo&lt;/A&gt; is obviously a work in progress. &lt;/P&gt; </description> 
      <content:encoded><![CDATA[<P><A HREF="http://www.mongodb.org"> mongo</A>  is a scalable, high-performance, open source, schema-free, document-oriented database. I was introduced to mongo at the <A HREF="http://www.meetup.com/mysqlnyc/messages/8346727/"> new-york mysql meetup</A> . Two things made mongo look attractive: inter-operability and document centric storage. <BR>  <BR>  I'm familiar with the <A HREF="http://common-lisp.net/project/elephant/"> elephant</A>  persistence framework in lisp. However elephant objects are not readable (as far as I know) in languages other than lisp.That makes inter-operating with other platforms difficult. A traditional rdms requires some sort of schema if you want to use it effectively. Mongo on the other hand is optimized for the the kind of free form document storage I'm looking for. <BR>  <BR>  Mongo comes with set of drivers but was missing was a lisp driver. This looked like a good project to get better acquainted with lisp and mongo.<BR>  <BR>  So I set out to try to write one and the result is <A HREF="http://github.com/fons/cl-mongo"> cl-mongo</A> . At this stage it's close to having the capabilities I'm looking for, but <A HREF="http://github.com/fons/cl-mongo"> cl-mongo</A>  is obviously a work in progress. </P>   ]]></content:encoded>
      <guid> http://fons.github.com/cl-mongo.html </guid>      
      <pubDate> Tue, 02 Feb 2010 18:59:51 EST </pubDate>
    </item>
    
    <item>
      <title> Fourth NYSA Machine Learning Seminar </title>
      <link> http://fons.github.com/fourth-nysa-machine-learning-seminar.html </link>
      <description> &lt;P&gt;Friday I attended the 4&lt;SUP&gt; th&lt;/SUP&gt;  Machine Learning Symposium organized by the New York Academy of Sciences &lt;A HREF="http://www.nyas.org/"&gt;(NYSA)&lt;/A&gt;.  &lt;BR&gt; &lt;BR&gt;  The &lt;A HREF="http://www.nyas.org/events/Detail.aspx?cid=533f8dfe-d778-4c52-ba1b-3241bc9c8ca2"&gt;Symposium program&lt;/A&gt; consisted of four main talks given by local experts in the area of machine learning, interspersed with four graduate student talks, a poster session and a terrific lunch. &lt;BR&gt; &lt;BR&gt;  Since I'm not really hindered by any overwhelming expertise in this area I'll confine my self to a few breezy impressions of the main talks.  &lt;BR&gt; &lt;BR&gt;  The first one was given by Bob Bell, from AT&amp;T Bell Labs and a member of the team which won the &lt;A HREF="http://www.netflixprize.com/"&gt;Netflix prize.&lt;/A&gt;&lt;BR&gt; &lt;BR&gt;  &lt;/P&gt;&lt;P&gt;What made the contest challenging was not only the huge size of the data set  but also the fact that 99 % of the data was missing. In addition there were significant differences between training and test data. Regardless of whether a 10 % improvement of a movie rating system should be worthy of a million dollar prize, it provided a great way to test classifiers against real world data.&lt;BR&gt; &lt;BR&gt;  One thing that stood out for me  was that a relative small amount of users was responsible for 'most' of the ratings. He mentioned that they identified one user responsible for 5400 ratings on one particular day. This &lt;EM&gt;could&lt;/EM&gt; an data error on the Netflix side, where the time stamp was somehow misapplied. On the other hand it sounds like someone was trying to deliberately affect a large swath of ratings.  &lt;BR&gt; &lt;BR&gt;  The final classifier incorporated breakthroughs made by different teams in the earlier stages of this multi-year competition.One such breakthrough was to consider the previous genres of the movies someone has rated to determine future recommendations. That must seem rather obvious in retrospect. The other was a clever way called &lt;A HREF="http://portal.acm.org/citation.cfm?id=1557072"&gt;Collaborative Filtering&lt;/A&gt; which takes into account the time-dependency of people's movie preferences. &lt;BR&gt; &lt;BR&gt;  An ensemble of previously validated classifiers was used to construct the final classifier and the calculation to get the final result submitted to Netflix took almost a month, primarily because a power failure forced a restart of the calculation engine. In fact the use of an ensemble of classifiers of mentioned as one of the main lessons learned from the contest. The other was the power matrix factorization (i.e. treating users and preferences as independent parameters and using matrix to link the two) as a computational tool. &lt;/P&gt; </description> 
      <content:encoded><![CDATA[<P>Friday I attended the 4<SUP>  th</SUP>   Machine Learning Symposium organized by the New York Academy of Sciences <A HREF="http://www.nyas.org/"> (NYSA)</A> .  <BR>  <BR>   The <A HREF="http://www.nyas.org/events/Detail.aspx?cid=533f8dfe-d778-4c52-ba1b-3241bc9c8ca2"> Symposium program</A>  consisted of four main talks given by local experts in the area of machine learning, interspersed with four graduate student talks, a poster session and a terrific lunch. <BR>  <BR>   Since I'm not really hindered by any overwhelming expertise in this area I'll confine my self to a few breezy impressions of the main talks.  <BR>  <BR>   The first one was given by Bob Bell, from AT&amp;T Bell Labs and a member of the team which won the <A HREF="http://www.netflixprize.com/"> Netflix prize.</A> <BR>  <BR>   </P> <P> What made the contest challenging was not only the huge size of the data set  but also the fact that 99 % of the data was missing. In addition there were significant differences between training and test data. Regardless of whether a 10 % improvement of a movie rating system should be worthy of a million dollar prize, it provided a great way to test classifiers against real world data.<BR>  <BR>   One thing that stood out for me  was that a relative small amount of users was responsible for 'most' of the ratings. He mentioned that they identified one user responsible for 5400 ratings on one particular day. This <EM> could</EM>  an data error on the Netflix side, where the time stamp was somehow misapplied. On the other hand it sounds like someone was trying to deliberately affect a large swath of ratings.  <BR>  <BR>   The final classifier incorporated breakthroughs made by different teams in the earlier stages of this multi-year competition.One such breakthrough was to consider the previous genres of the movies someone has rated to determine future recommendations. That must seem rather obvious in retrospect. The other was a clever way called <A HREF="http://portal.acm.org/citation.cfm?id=1557072"> Collaborative Filtering</A>  which takes into account the time-dependency of people's movie preferences. <BR>  <BR>   An ensemble of previously validated classifiers was used to construct the final classifier and the calculation to get the final result submitted to Netflix took almost a month, primarily because a power failure forced a restart of the calculation engine. In fact the use of an ensemble of classifiers of mentioned as one of the main lessons learned from the contest. The other was the power matrix factorization (i.e. treating users and preferences as independent parameters and using matrix to link the two) as a computational tool. </P>   ]]></content:encoded>
      <guid> http://fons.github.com/fourth-nysa-machine-learning-seminar.html </guid>      
      <pubDate> Sat, 07 Nov 2009 09:49:51 EST </pubDate>
    </item>
    
    <item>
      <title> Embedding Equations in a Blog Post </title>
      <link> http://fons.github.com/embedding-equations-in-a-blog-post.html </link>
      <description> &lt;P&gt;I'm using a &lt;A HREF="http://github.com/fons/cl-bliky"&gt;home-grown blogging engine&lt;/A&gt; which converts pages formatted in &lt;A HREF="http://daringfireball.net/projects/markdown/"&gt;markdown&lt;/A&gt; to static html pages served from my &lt;A HREF="http://github.com/fons/fons.github.com"&gt;github account.&lt;/A&gt; If I want to include mathematical equations in my blog post my options are to use inline html code or to use one of the online &lt;A HREF="http://www.latex-project.org/"&gt;Latex&lt;/A&gt;&lt;A HREF="http://www.google.com/search?q=online+latex+equation+editor"&gt; equation editors.&lt;/A&gt;&lt;BR&gt; &lt;BR&gt; My requirements are simple: I want to be able to use the usual cast of mathematical symbols inlined in my main text as well format large equation blocks.  In this post I'll compare and contrast inline html with online editors provided by &lt;A HREF="http://www.sitmo.com/latex/"&gt;SITMO&lt;/A&gt;, &lt;A HREF="http://www.codecogs.com/components/equationeditor/equationeditor.php"&gt;CodeCogs&lt;/A&gt; and &lt;A HREF="http://www.texify.com/"&gt;Textify&lt;/A&gt;. &lt;BR&gt; &lt;BR&gt; To save you the trouble of having to wade through miles of text, I'll start of with my &lt;/P&gt;&lt;H2&gt;Conclusions&lt;/H2&gt;&lt;P&gt;Use HTML for inlining symbols and equations. Although those will never look as good in html as in Latex, the overall format of your text will suffer less.&lt;BR&gt; &lt;BR&gt; For equation blocks you have the choice between two online editors : &lt;A HREF="http://www.sitmo.com/latex/"&gt;SITMO&lt;/A&gt;, &lt;A HREF="http://www.codecogs.com/components/equationeditor/equationeditor.php"&gt;CodeCogs&lt;/A&gt;. When it comes to embedding latex code into your html both editors are comparable. When you're looking for more variety with regard to fonts or markup languages CodeCogs is your only alternative.&lt;BR&gt; &lt;BR&gt; If you want to use the url link to embed a large code block you probably would want to use a url shortner. &lt;A HREF="" HTTP:="http:" TINY.URL="tiny.url"&gt;Tiny url&lt;/A&gt; is a good option here.As an alternative both editors can generate a png image for you to embed.&lt;BR&gt; &lt;BR&gt;&lt;A HREF="" HTTP:="http:" WWW.TEXIFY.COM="www.texify.com" LINKS.PHP="links.php"&gt;Textify&lt;/A&gt; has a nice clean interface, but I can't embed the links it generates. My only alternative would appear to be to run my own instance of this service which is obviously not something I need or want to do. Furthermore, although it cleverly provides a shortened url, it uses &lt;A HREF="" HTTP:="http:" BIT.LY="bit.ly"&gt;bit.ly&lt;/A&gt; which unfortunately doesn't handle complex latex url's well.. &lt;BR&gt; &lt;BR&gt; Read on to find out how I reached these conclusions . &lt;/P&gt; </description> 
      <content:encoded><![CDATA[<P>I'm using a <A HREF="http://github.com/fons/cl-bliky"> home-grown blogging engine</A>  which converts pages formatted in <A HREF="http://daringfireball.net/projects/markdown/"> markdown</A>  to static html pages served from my <A HREF="http://github.com/fons/fons.github.com"> github account.</A>  If I want to include mathematical equations in my blog post my options are to use inline html code or to use one of the online <A HREF="http://www.latex-project.org/"> Latex</A> <A HREF="http://www.google.com/search?q=online+latex+equation+editor">  equation editors.</A> <BR>  <BR>  My requirements are simple: I want to be able to use the usual cast of mathematical symbols inlined in my main text as well format large equation blocks.  In this post I'll compare and contrast inline html with online editors provided by <A HREF="http://www.sitmo.com/latex/"> SITMO</A> , <A HREF="http://www.codecogs.com/components/equationeditor/equationeditor.php"> CodeCogs</A>  and <A HREF="http://www.texify.com/"> Textify</A> . <BR>  <BR>  To save you the trouble of having to wade through miles of text, I'll start of with my </P> <H2> Conclusions</H2> <P> Use HTML for inlining symbols and equations. Although those will never look as good in html as in Latex, the overall format of your text will suffer less.<BR>  <BR>  For equation blocks you have the choice between two online editors : <A HREF="http://www.sitmo.com/latex/"> SITMO</A> , <A HREF="http://www.codecogs.com/components/equationeditor/equationeditor.php"> CodeCogs</A> . When it comes to embedding latex code into your html both editors are comparable. When you're looking for more variety with regard to fonts or markup languages CodeCogs is your only alternative.<BR>  <BR>  If you want to use the url link to embed a large code block you probably would want to use a url shortner. <A HREF="" HTTP:="http:" TINY.URL="tiny.url"> Tiny url</A>  is a good option here.As an alternative both editors can generate a png image for you to embed.<BR>  <BR> <A HREF="" HTTP:="http:" WWW.TEXIFY.COM="www.texify.com" LINKS.PHP="links.php"> Textify</A>  has a nice clean interface, but I can't embed the links it generates. My only alternative would appear to be to run my own instance of this service which is obviously not something I need or want to do. Furthermore, although it cleverly provides a shortened url, it uses <A HREF="" HTTP:="http:" BIT.LY="bit.ly"> bit.ly</A>  which unfortunately doesn't handle complex latex url's well.. <BR>  <BR>  Read on to find out how I reached these conclusions . </P>   ]]></content:encoded>
      <guid> http://fons.github.com/embedding-equations-in-a-blog-post.html </guid>      
      <pubDate> Fri, 06 Nov 2009 06:32:19 EST </pubDate>
    </item>
    
    <item>
      <title> Toy Problem: Simple One Dimensional Least Squares Learner. </title>
      <link> http://fons.github.com/toy-problem-simple-one-dimensional-least-squares-learner.html </link>
      <description> &lt;P&gt;In chapter two of Hastie, Tibshirani and Friedman 's  &lt;A HREF="http://www-stat.stanford.edu/~tibs/ElemStatLearn/"&gt;'The Elements of Statistical Learning'&lt;/A&gt;  the authors discuss the use of least- squares regression to construct a data classifier for linearly separable data. &lt;BR&gt; &lt;BR&gt;  A set of training data together with the least-squares method is used to construct a hyper-plane in the data space. The classification of a data point depends on what side of the hyper-plane you end up on.&lt;BR&gt; &lt;BR&gt;  The example in Hastie uses two data classes in a two dimensional parameter space. I didn't grok the the example immediately, and I thought it would be helpful to try to construct my own much simpler example by staying in one dimension and using a simple normal distribution. The rest of this post describes the details. &lt;/P&gt; </description> 
      <content:encoded><![CDATA[<P>In chapter two of Hastie, Tibshirani and Friedman 's  <A HREF="http://www-stat.stanford.edu/~tibs/ElemStatLearn/"> 'The Elements of Statistical Learning'</A>   the authors discuss the use of least- squares regression to construct a data classifier for linearly separable data. <BR>  <BR>   A set of training data together with the least-squares method is used to construct a hyper-plane in the data space. The classification of a data point depends on what side of the hyper-plane you end up on.<BR>  <BR>   The example in Hastie uses two data classes in a two dimensional parameter space. I didn't grok the the example immediately, and I thought it would be helpful to try to construct my own much simpler example by staying in one dimension and using a simple normal distribution. The rest of this post describes the details. </P>   ]]></content:encoded>
      <guid> http://fons.github.com/toy-problem-simple-one-dimensional-least-squares-learner.html </guid>      
      <pubDate> Sun, 01 Nov 2009 10:30:37 EST </pubDate>
    </item>
    
    <item>
      <title> Processing the Sieve in Python </title>
      <link> http://fons.github.com/processing-the-sieve-in-python.html </link>
      <description> &lt;P&gt;In a &lt;A HREF="http://www.prognotes.com/threading-the-sieve-in-python.html"&gt;previous post&lt;/A&gt; I discussed four methods to multi-thread the &lt;A HREF="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"&gt;Sieve of Erasthones&lt;/A&gt; in Python. I concluded that multi-threading didn't increase performance, and in fact could have a significant adverse effect. The &lt;A HREF="www.dabeaz.com/python/GIL.pdf"&gt;global interpretor lock (GIL)&lt;/A&gt; prevents threads from running concurrently and thus limits the upside of threading. The use of locks or avoiding the use of shared data can than decrease performance quite a bit. &lt;BR&gt; &lt;BR&gt;  In this section I'll be using Python's &lt;A HREF="http://docs.python.org/library/multiprocessing.html"&gt;multiprocessing&lt;/A&gt; module to 'multi-thread' the &lt;EM&gt;Sieve&lt;/EM&gt;. &lt;BR&gt; &lt;BR&gt;  The multiprocessing module spawns a number of processes and distributes the calculation amongst them.There is no equivalent to the GIL so I should be able to see some gain in performance as the number of processes increases. On the other hand, spawning processes means that there is startup overhead which may offset any performance gain due to the distribution of its execution across multiple processes.  However, I should still be able to investigate how performance scales with the number of processes, and whether the &lt;A HREF="http://docs.python.org/library/multiprocessing.html"&gt;multiprocessing module&lt;/A&gt; is able to take advantage of multiple cores. In this post I'll discuss four approaches to distributing the &lt;EM&gt;Sieve&lt;/EM&gt; algorithm, basically following the approaches I discussed &lt;A HREF="http://www.prognotes.com/threading-the-sieve-in-python.html"&gt;earlier&lt;/A&gt; when using the multi-threading package.The various approaches differ in the way the load is balanced and whether the state of the sieve is shared.&lt;BR&gt; &lt;BR&gt;  The source for the code discussed here and in the  &lt;A HREF="http://www.prognotes.com/threading-the-sieve-in-python.html"&gt;previous post&lt;/A&gt; can be found in  &lt;EM&gt;prime_share.py&lt;/EM&gt; in the &lt;A HREF="git://github.com/fons/blog-code.git"&gt;blog-code package&lt;/A&gt; on github. &lt;/P&gt; </description> 
      <content:encoded><![CDATA[<P>In a <A HREF="http://www.prognotes.com/threading-the-sieve-in-python.html"> previous post</A>  I discussed four methods to multi-thread the <A HREF="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"> Sieve of Erasthones</A>  in Python. I concluded that multi-threading didn't increase performance, and in fact could have a significant adverse effect. The <A HREF="www.dabeaz.com/python/GIL.pdf"> global interpretor lock (GIL)</A>  prevents threads from running concurrently and thus limits the upside of threading. The use of locks or avoiding the use of shared data can than decrease performance quite a bit. <BR>  <BR>   In this section I'll be using Python's <A HREF="http://docs.python.org/library/multiprocessing.html"> multiprocessing</A>  module to 'multi-thread' the <EM> Sieve</EM> . <BR>  <BR>   The multiprocessing module spawns a number of processes and distributes the calculation amongst them.There is no equivalent to the GIL so I should be able to see some gain in performance as the number of processes increases. On the other hand, spawning processes means that there is startup overhead which may offset any performance gain due to the distribution of its execution across multiple processes.  However, I should still be able to investigate how performance scales with the number of processes, and whether the <A HREF="http://docs.python.org/library/multiprocessing.html"> multiprocessing module</A>  is able to take advantage of multiple cores. In this post I'll discuss four approaches to distributing the <EM> Sieve</EM>  algorithm, basically following the approaches I discussed <A HREF="http://www.prognotes.com/threading-the-sieve-in-python.html"> earlier</A>  when using the multi-threading package.The various approaches differ in the way the load is balanced and whether the state of the sieve is shared.<BR>  <BR>   The source for the code discussed here and in the  <A HREF="http://www.prognotes.com/threading-the-sieve-in-python.html"> previous post</A>  can be found in  <EM> prime_share.py</EM>  in the <A HREF="git://github.com/fons/blog-code.git"> blog-code package</A>  on github. </P>   ]]></content:encoded>
      <guid> http://fons.github.com/processing-the-sieve-in-python.html </guid>      
      <pubDate> Sun, 27 Sep 2009 14:52:50 EST </pubDate>
    </item>
    
    <item>
      <title> Threading the Sieve in Python </title>
      <link> http://fons.github.com/threading-the-sieve-in-python.html </link>
      <description> &lt;P&gt;This is the first of two posts on threading and multiprocessing in Python. In this post I'll explore the thread module and in the second post I'll look at Python's multiprocessing module. My starting point is the multi-threaded implementation of the &lt;A HREF="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"&gt;Sieve of Erasthones&lt;/A&gt; found in this &lt;A HREF="http://heather.cs.ucdavis.edu/~matloff/Python/PyThreads.pdf"&gt;tutorial on multi-threading in Python (pdf).&lt;/A&gt;&lt;BR&gt; &lt;BR&gt; Threading a compute-bound algorithm, like the &lt;EM&gt;Sieve&lt;/EM&gt; consists of subdividing of the main task into autonomous sub-tasks which share as little state as possible. Having no shared state eliminates the overhead that inevitably comes with locking. It turns out that Python is not very good at multi-threading compute-bound processes. &lt;A HREF="http://www.dabeaz.com/blog/dablog.html"&gt;This &lt;/A&gt;&lt;A HREF="http://ttimo.vox.com/library/post/python-gil-threading-and-multicore-hardware.html"&gt;is &lt;/A&gt;&lt;A HREF="http://www.grouplens.org/node/244"&gt;not a &lt;/A&gt;&lt;A HREF="http://blog.ianbicking.org/gil-of-doom.html"&gt;surprise.&lt;/A&gt;  CPython has a global interpretor lock &lt;A HREF="http://www.dabeaz.com/python/GIL.pdf"&gt;(GIL)&lt;/A&gt; which prevents threads from running concurrently. &lt;BR&gt; &lt;BR&gt;  Regardless, there are other lessons I learned when multi-threading the &lt;EM&gt;Sieve&lt;/EM&gt; algorithm. One is that sharing state between threads may be unavoidable to achieve reasonable performance. In fact, if you &lt;EM&gt;don't&lt;/EM&gt; share state, performance can become predictable &lt;EM&gt;worse&lt;/EM&gt; as the number of threads of execution increases. &lt;BR&gt; &lt;BR&gt; The other is that locking can have a surprising impact on performance. It's not just the cost of locking per se, but the effect locking has on the distribution of work between the various threads. &lt;/P&gt; </description> 
      <content:encoded><![CDATA[<P>This is the first of two posts on threading and multiprocessing in Python. In this post I'll explore the thread module and in the second post I'll look at Python's multiprocessing module. My starting point is the multi-threaded implementation of the <A HREF="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"> Sieve of Erasthones</A>  found in this <A HREF="http://heather.cs.ucdavis.edu/~matloff/Python/PyThreads.pdf"> tutorial on multi-threading in Python (pdf).</A> <BR>  <BR>  Threading a compute-bound algorithm, like the <EM> Sieve</EM>  consists of subdividing of the main task into autonomous sub-tasks which share as little state as possible. Having no shared state eliminates the overhead that inevitably comes with locking. It turns out that Python is not very good at multi-threading compute-bound processes. <A HREF="http://www.dabeaz.com/blog/dablog.html"> This </A> <A HREF="http://ttimo.vox.com/library/post/python-gil-threading-and-multicore-hardware.html"> is </A> <A HREF="http://www.grouplens.org/node/244"> not a </A> <A HREF="http://blog.ianbicking.org/gil-of-doom.html"> surprise.</A>   CPython has a global interpretor lock <A HREF="http://www.dabeaz.com/python/GIL.pdf"> (GIL)</A>  which prevents threads from running concurrently. <BR>  <BR>   Regardless, there are other lessons I learned when multi-threading the <EM> Sieve</EM>  algorithm. One is that sharing state between threads may be unavoidable to achieve reasonable performance. In fact, if you <EM> don't</EM>  share state, performance can become predictable <EM> worse</EM>  as the number of threads of execution increases. <BR>  <BR>  The other is that locking can have a surprising impact on performance. It's not just the cost of locking per se, but the effect locking has on the distribution of work between the various threads. </P>   ]]></content:encoded>
      <guid> http://fons.github.com/threading-the-sieve-in-python.html </guid>      
      <pubDate> Sat, 12 Sep 2009 17:03:23 EST </pubDate>
    </item>
    
    <item>
      <title> Simplified command line processing with dyn-options.py </title>
      <link> http://fons.github.com/simplified-command-line-processing-with-dyn-optionspy.html </link>
      <description> &lt;P&gt;Am I the only one in the world who feels that using python's  &lt;EM&gt;getopt&lt;/EM&gt; is a bit of a struggle ? It involves a lot of boiler plate. Tedious refactoring is required each time you add or change an option.  This is not specific to Python, as most languages have a similar facility to parse the command line, which is similarly annoying. &lt;BR&gt; &lt;BR&gt;  I decided to create an easier way to process command line options, by transforming the command line into an immutable (read-only) object. The result is &lt;A HREF="http://github.com/fons/dyn_options/tree/master"&gt;dyn_options&lt;/A&gt;. &lt;BR&gt; &lt;BR&gt;  &lt;A HREF="http://github.com/fons/dyn_options/tree/master"&gt;dyn_options&lt;/A&gt; considers every string on the command line which starts with either  - or -- (i.e. a single or double dash) an option flag. The value of the option flag is a concatenation of everything that follows it, until the next flag is encountered.  A simple option flag is one without explicit values and is considered a boolean flag, set to &lt;EM&gt;True&lt;/EM&gt;. &lt;A HREF="http://github.com/fons/dyn_options/tree/master"&gt;dyn_options&lt;/A&gt; creates a read-only object, with attributes and values set to the command line option flags and values respectively. &lt;BR&gt; &lt;BR&gt;  So, '--opt4 hello world' will be converted to an option flag  called &lt;EM&gt;opt4&lt;/EM&gt;, with a value of &lt;EM&gt;hello world&lt;/EM&gt;. This makes dealing with spaces on the command line a lot easier. &lt;/P&gt; </description> 
      <content:encoded><![CDATA[<P>Am I the only one in the world who feels that using python's  <EM> getopt</EM>  is a bit of a struggle ? It involves a lot of boiler plate. Tedious refactoring is required each time you add or change an option.  This is not specific to Python, as most languages have a similar facility to parse the command line, which is similarly annoying. <BR>  <BR>   I decided to create an easier way to process command line options, by transforming the command line into an immutable (read-only) object. The result is <A HREF="http://github.com/fons/dyn_options/tree/master"> dyn_options</A> . <BR>  <BR>   <A HREF="http://github.com/fons/dyn_options/tree/master"> dyn_options</A>  considers every string on the command line which starts with either  - or -- (i.e. a single or double dash) an option flag. The value of the option flag is a concatenation of everything that follows it, until the next flag is encountered.  A simple option flag is one without explicit values and is considered a boolean flag, set to <EM> True</EM> . <A HREF="http://github.com/fons/dyn_options/tree/master"> dyn_options</A>  creates a read-only object, with attributes and values set to the command line option flags and values respectively. <BR>  <BR>   So, '--opt4 hello world' will be converted to an option flag  called <EM> opt4</EM> , with a value of <EM> hello world</EM> . This makes dealing with spaces on the command line a lot easier. </P>   ]]></content:encoded>
      <guid> http://fons.github.com/simplified-command-line-processing-with-dyn-optionspy.html </guid>      
      <pubDate> Sat, 29 Aug 2009 19:15:49 EST </pubDate>
    </item>
    
    <item>
      <title> Factorials, Tail Recursion and CPS ... in C </title>
      <link> http://fons.github.com/factorials-tail-recursion-and-cps--in-c.html </link>
      <description> &lt;P&gt;Recursive algorithms are elegant. However, if the recursion is not a  &lt;A HREF="http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-453.pdf"&gt;tail call&lt;/A&gt;  the growth of the stack leads to a stack overflow. &lt;/P&gt;&lt;P&gt;Tail call recursion is a technique whereby the last call in a recursive function does not depend on the variables pushed on the stack. In other words the function returns the value of its additional (recursive) call. &lt;/P&gt;&lt;P&gt;Functional languages like Haskell or Lisp are designed to support the use of tail recursive algorithms.The JVM -although now the target platform of a lisp like &lt;A HREF="http://www.clojure.org"&gt;clojure&lt;/A&gt; or a hybrid functional language like &lt;A HREF="http://www.scala-lang.org"&gt;scala&lt;/A&gt; - &lt;A HREF="http://blogs.sun.com/jrose/entry/tail_calls_in_the_vm"&gt;does not support tail recursion at all&lt;/A&gt;. In C/C++ the compiler can in fact replace tail recursive calls with a simple loop, thereby eliminating the allocation for additional stack frames all together. In this post I'll consider various implementations of the humble factorial to illustrate some of these things. &lt;/P&gt; </description> 
      <content:encoded><![CDATA[<P>Recursive algorithms are elegant. However, if the recursion is not a  <A HREF="http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-453.pdf"> tail call</A>   the growth of the stack leads to a stack overflow. </P> <P> Tail call recursion is a technique whereby the last call in a recursive function does not depend on the variables pushed on the stack. In other words the function returns the value of its additional (recursive) call. </P> <P> Functional languages like Haskell or Lisp are designed to support the use of tail recursive algorithms.The JVM -although now the target platform of a lisp like <A HREF="http://www.clojure.org"> clojure</A>  or a hybrid functional language like <A HREF="http://www.scala-lang.org"> scala</A>  - <A HREF="http://blogs.sun.com/jrose/entry/tail_calls_in_the_vm"> does not support tail recursion at all</A> . In C/C++ the compiler can in fact replace tail recursive calls with a simple loop, thereby eliminating the allocation for additional stack frames all together. In this post I'll consider various implementations of the humble factorial to illustrate some of these things. </P>   ]]></content:encoded>
      <guid> http://fons.github.com/factorials-tail-recursion-and-cps--in-c.html </guid>      
      <pubDate> Sun, 09 Aug 2009 10:27:45 EST </pubDate>
    </item>
    
    <item>
      <title> CL-BLIKY : A simple lisp based blog engine </title>
      <link> http://fons.github.com/cl-bliky--a-simple-lisp-based-blog-engine.html </link>
      <description> &lt;P&gt;I 'm writing this using a self rolled blog engine called cl-bliky. I'm indebted to an excellent &lt;A HREF="http://roeim.net/vetle/docs/cl-webapp-intro/"&gt;tutorial&lt;/A&gt; put together by &lt;A HREF="http://roeim.net/vetle/"&gt;Vetle Roeim&lt;/A&gt;. His goal was obviously to put together a compelling tutorial and he succeeded. My goal was to use lisp in a small programming project, and developing a simple and easily customizable blog engine seemed like a good start. &lt;/P&gt; </description> 
      <content:encoded><![CDATA[<P>I 'm writing this using a self rolled blog engine called cl-bliky. I'm indebted to an excellent <A HREF="http://roeim.net/vetle/docs/cl-webapp-intro/"> tutorial</A>  put together by <A HREF="http://roeim.net/vetle/"> Vetle Roeim</A> . His goal was obviously to put together a compelling tutorial and he succeeded. My goal was to use lisp in a small programming project, and developing a simple and easily customizable blog engine seemed like a good start. </P>   ]]></content:encoded>
      <guid> http://fons.github.com/cl-bliky--a-simple-lisp-based-blog-engine.html </guid>      
      <pubDate> Sun, 19 Jul 2009 11:49:05 EST </pubDate>
    </item>
    
  </channel>
</rss>

